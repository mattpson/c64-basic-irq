// Simple C64 Interrupt 
// ====================
// KickAssembler




//--------------------------------------------------
// Basic starter ($0801 - $080d)
//--------------------------------------------------

:BasicUpstart2(Startup)

	.byte 0,0,0
	.text "<I was here 2021>"
	.byte 0,0,0
	
Startup:
	nop		// always start with a nop for no reason at all
				// if you have some code that needs to run first insert it here
	
StartIrq:
	sei        // disable maskable IRQs

	lda #$7f
	sta $dc0d  // disable timer interrupts which can be generated by the two CIA chips
	sta $dd0d  // the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
	           // stop it.

	lda $dc0d  // by reading this two registers we negate any pending CIA irqs.
	lda $dd0d  // if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
	           // we don't want that to happen.

	lda #$01   // this is how to tell the VICII to generate a raster interrupt
	sta $d01a

	lda #$80   // this is how to tell at which rasterline we want the irq to be triggered
	sta $d012

	lda #$1b   // as there are more than 256 rasterlines, the topmost bit of $d011 serves as
	sta $d011  // the 9th bit for the rasterline we want our irq to be triggered.
	           // here we simply set up a character screen, leaving the topmost bit 0.

	lda #$35   // we turn off the BASIC and KERNAL rom here
	sta $01    // the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
	           // SID/VICII/etc are visible

	lda #<Irq  // this is how we set up
	sta $fffe  // the address of our interrupt code
	lda #>Irq
	sta $ffff

	cli        // enable maskable interrupts again

	jmp *      // we better don't RTS, the ROMS are now switched off, there's no way back to the system

//--------------------------------------------------
// Interrupt
//--------------------------------------------------

Irq:

	pha        // store register A in stack
	txa
	pha        // store register X in stack
	tya
	pha        // store register Y in stack

	lda #$ff	 // clear the intrerrupt in VIC
	sta $d019	 


// some example code, wait for the next rasterline and the fiddle
// with border and screen colour

	lda $d012 // load the current raster line into the accumulator
	cmp $d012 // check if it has changed
	beq *-3   // if not, jump back and check again

	inc $d020
	inc $d021


	lda $d012
	clc       // make sure carry is clear
	adc #$18  // add lines to wait
	cmp $d012
	bne *-3   // check *until* we're at the target raster line

	dec $d020
	dec $d021

// end of example code

	pla
	tay        // restore register Y from stack (remember stack is FIFO: First In First Out)
	pla
	tax        // restore register X from stack
	pla        // restore register A from stack

	rti        // Return From Interrupt, this will load into the Program Counter register the address
	           // where the CPU was when the interrupt condition arised which will make the CPU continue
	           // the code it was interrupted at also restores the status register of the CPU